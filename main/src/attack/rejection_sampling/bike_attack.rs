use std::{
    fs::File,
    io::{BufWriter, Write},
    marker::PhantomData,
    ops::Range,
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicBool, AtomicU32, Ordering},
        Arc,
    },
};

use csv::Writer;
use libflate::finish::AutoFinishUnchecked;
use liboqs_rs_bindings as oqs;
use log::{debug, info};
use log_derive::logfn_inputs;
use oqs::{bike::Bike, Kem, KemBuf};
use rand::{thread_rng, Rng};
use structopt::StructOpt;

use crate::{
    attack::rejection_sampling::{
        attack::get_keypair,
        bike_error_weight::{
            construct_decoding_failure_oracle, random_sparse_error_pattern, BikeIdealizedOracle,
            DecodingFailureOracle, SparseErrorPattern,
        },
    },
    utils::{thread_work, ClonableProgressManager, ProgressBars, StrErr},
};

type DistanceSpectrum = Vec<u32>;
struct DistanceSpectrumCollection {
    f: DistanceSpectrum,
    g: DistanceSpectrum,
    a: DistanceSpectrum,
    b: DistanceSpectrum,
    num_failures: u32,
    num_successes: u32,
}

#[derive(Debug, StructOpt)]
pub struct BikeAttackOptions {
    /// The number of threads to use
    #[structopt(short("t"), long)]
    threads: usize,
    /// The hamming weight of the error patterns to use.
    #[structopt(short("w"), long)]
    hamming_weight: usize,
    /// The number of decoding failures to collect before doing
    /// the key recovery step from the collected distance spectrum.
    #[structopt(short("c"), long)]
    chain_length: u32,
    /// The probability of making a bad distinguisher decision, between 0.0 and 1.0
    #[structopt(short, long, default_value("0.0"))]
    epsilon: f64,
    /// Location of plaintext database generated by the "attack rejection-sampling collect-plaintexts" command
    #[structopt(short("d"), long("db"))]
    pub plaintext_db: PathBuf,
    /// Location of serialized key pair file. Will be created with a random key if it does not exists.
    #[structopt(short("k"), long)]
    pub reuse_key_pair: Option<PathBuf>,
    /// Where to write the resulting GZIP compressed CSV file, e.g. "bike-ds.csv.gz" containing the distance spectrum to
    #[structopt(short("f"), long)]
    pub destination: PathBuf,
}

#[derive(Debug, Clone)]
struct EpsilonWrappedOracle<INNER, BIKE>
where
    INNER: DecodingFailureOracle<BIKE>,
    BIKE: Bike + Send,
{
    inner: INNER,
    pub epsilon: f64,
    since_inversion: u32,
    _bike: PhantomData<BIKE>,
}

impl<INNER, BIKE> EpsilonWrappedOracle<INNER, BIKE>
where
    INNER: DecodingFailureOracle<BIKE>,
    BIKE: Bike + Send,
{
    fn wrap(inner: INNER, epsilon: f64) -> Self {
        EpsilonWrappedOracle {
            inner,
            epsilon,
            since_inversion: 0,
            _bike: PhantomData,
        }
    }
}

impl<INNER, BIKE> DecodingFailureOracle<BIKE> for EpsilonWrappedOracle<INNER, BIKE>
where
    INNER: DecodingFailureOracle<BIKE>,
    BIKE: Bike + Send,
{
    const NAME: &'static str = INNER::NAME;

    fn generate(
        num_profiling: i32,
        num_decaps: i32,
        num_validate: u32,
        pt: &mut BIKE::Plaintext,
        pt_delta: &mut BIKE::Plaintext,
        pk: &mut BIKE::PublicKey,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<Self>, String>
    where
        Self: Sized,
    {
        if let Some(inner) = INNER::generate(
            num_profiling,
            num_decaps,
            num_validate,
            pt,
            pt_delta,
            pk,
            sk,
        )? {
            Ok(Some(EpsilonWrappedOracle::wrap(inner, 0.0)))
        } else {
            Ok(None)
        }
    }

    fn decoding_failure(
        &mut self,
        ct: &mut BIKE::Ciphertext,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<bool>, String> {
        Ok(if let Some(res) = self.inner.decoding_failure(ct, sk)? {
            // With epsilon probability we return the inverted result
            Some({
                let mut invert = false;
                if self.epsilon > 0.0 {
                    self.since_inversion += 1;
                    if thread_rng().gen_bool(self.epsilon) {
                        debug!(
                            "Due to epsilon = {} we inverted the detected decoding failure: {} to decoding failure: {} ({} since last inversion)",
                            self.epsilon,
                            res,
                            !res,
                            self.since_inversion
                        );
                        self.since_inversion = 0;
                        invert = true;
                    }
                }
                res ^ invert
            })
        } else {
            None
        })
    }
}

#[derive(Debug)]
enum GenesisSearchResults {
    Success((SparseErrorPattern, u32)),
    Interrupted(u32),
}

fn search_genesis_pattern<BIKE, ORACLE>(
    pk: &mut BIKE::PublicKey,
    sk: &mut BIKE::SecretKey,
    pt: &mut BIKE::Plaintext,
    oracle: &mut ORACLE,
    hamming_weight: usize,
    error_range: Range<usize>,
    abort: Arc<AtomicBool>,
) -> Result<Option<GenesisSearchResults>, String>
where
    BIKE: Bike,
    ORACLE: DecodingFailureOracle<BIKE>,
{
    debug!("Searching for genesis pattern...");
    let mut ss = BIKE::SharedSecret::new();
    let mut ct = BIKE::Ciphertext::new();
    for attempt in 1.. {
        let rsep = random_sparse_error_pattern(error_range.clone(), hamming_weight)?;
        BIKE::encaps_with_plaintext_and_error_pattern(&mut ct, &mut ss, pk, pt, &rsep)?;
        if let Some(decoding_failure) = oracle.decoding_failure(&mut ct, sk)? {
            if decoding_failure {
                info!("Found a genesis pattern!");
                return Ok(Some(GenesisSearchResults::Success((rsep, attempt))));
            }
        }
        if abort.load(Ordering::Relaxed) {
            return Ok(Some(GenesisSearchResults::Interrupted(attempt)));
        }
    }
    unreachable!()
}

enum DSDiff {
    Add(u32),
    Del(u32),
}

fn iter_ds_diff<BIKE: Bike>(
    op: &SparseErrorPattern,
    del: u32,
    add: u32,
) -> impl Iterator<Item = DSDiff> + '_ {
    let r = BIKE::params::<u32>().PARAM_R;
    let distance = move |a: u32, b: u32| {
        let d = a.abs_diff(b);
        //info!("a: {}, b: {}, d: {}, r: {}", a, b, d, r);
        assert!(d < r);
        std::cmp::min(d, r - d)
    };
    op.iter().flat_map(move |bitnum| {
        let i = std::iter::once(DSDiff::Del(distance(*bitnum, del)));
        let i = i.chain(std::iter::once(DSDiff::Add(distance(*bitnum, add))));
        i.filter(move |_| *bitnum != del)
    })
}

#[allow(clippy::too_many_arguments)]
fn generate_lists_fgab<BIKE, ORACLE>(
    pk: &mut BIKE::PublicKey,
    sk: &mut BIKE::SecretKey,
    pt: &mut BIKE::Plaintext,
    oracle: &mut ORACLE,
    mut error_pattern: SparseErrorPattern,
    chain_length: u32,
    error_range: Range<usize>,
    sync: Arc<AtomicU32>,
) -> Result<DistanceSpectrumCollection, String>
where
    BIKE: Bike,
    ORACLE: DecodingFailureOracle<BIKE>,
{
    debug!("Starting generation of distance spectrum...");
    let max_distance = (BIKE::params::<usize>().PARAM_R + 1) / 2;
    // F,G,A,B ← empty vectors
    let mut f = vec![0; max_distance];
    let mut g = vec![0; max_distance];
    let mut a = vec![0; max_distance];
    let mut b = vec![0; max_distance];

    let mut ct = BIKE::Ciphertext::new();
    let mut ss = BIKE::SharedSecret::new();

    let mut mutations = 0;
    let mut num_failures = 0;
    let mut num_successes = 0;
    while sync.load(Ordering::Relaxed) < chain_length {
        let (mutated_error_pattern, del, add) =
            mutate_error_pattern(&error_pattern, error_range.clone());
        mutations += 1;
        BIKE::encaps_with_plaintext_and_error_pattern(
            &mut ct,
            &mut ss,
            pk,
            pt,
            &mutated_error_pattern,
        )?;
        if let Some(decoding_failure) = oracle.decoding_failure(&mut ct, sk)? {
            let iter_diffs = iter_ds_diff::<BIKE>(&error_pattern, del, add);
            if decoding_failure {
                // confirm results before succeeding
                if let Some(true) = oracle.decoding_failure(&mut ct, sk)? {
                    num_failures += 1;
                    for diff in iter_diffs {
                        match diff {
                            DSDiff::Add(distance) => f[distance as usize] += 1,
                            DSDiff::Del(distance) => g[distance as usize] += 1,
                        }
                    }
                    error_pattern = mutated_error_pattern;
                    let current_chain_length = sync.fetch_add(1, Ordering::Relaxed) + 1;
                    debug!(
                        "decoding failure {} after {} mutations",
                        current_chain_length, mutations
                    );
                    mutations = 0;
                } else {
                    // We ignore this result
                }
            } else {
                num_successes += 1;
                for diff in iter_diffs {
                    match diff {
                        DSDiff::Add(distance) => a[distance as usize] += 1,
                        DSDiff::Del(distance) => b[distance as usize] += 1,
                    }
                }
            }
        }
    }

    Ok(DistanceSpectrumCollection {
        f,
        g,
        a,
        b,
        num_failures,
        num_successes,
    })
}

fn mutate_error_pattern(
    error_pattern: &SparseErrorPattern,
    range: Range<usize>,
) -> (SparseErrorPattern, u32, u32) {
    let mut rng = thread_rng();
    let mut error_pattern = error_pattern.clone();
    let idx = rng.gen_range(0..error_pattern.len());
    let del = error_pattern[idx];
    loop {
        let add = rng.gen_range(range.clone()) as u32;
        if !error_pattern.contains(&add) {
            error_pattern[idx] = add;
            return (error_pattern, del, add);
        }
    }
}

fn attack<BIKE, ORACLE>(
    opt: BikeAttackOptions,
    pk: BIKE::PublicKey,
    sk: BIKE::SecretKey,
    pt: BIKE::Plaintext,
    mut oracle: EpsilonWrappedOracle<ORACLE, BIKE>,
) -> Result<(), String>
where
    BIKE: Bike + Send + 'static,
    ORACLE: DecodingFailureOracle<BIKE> + 'static,
{
    let params = BIKE::params();
    let error_range = params.PARAM_R..params.PARAM_N;
    oracle.epsilon = 0.0; // Zero for the first phase

    // Find the first e which causes a decoding failure
    info!("Starting search for genesis pattern!");

    let hamming_weight = opt.hamming_weight;
    let mut patterns = {
        let pk = pk.clone();
        let sk = sk.clone();
        let pt = pt.clone();
        let oracle = oracle.clone();
        let error_range = error_range.clone();
        let search_results = thread_work(
            opt.threads,
            (pk, sk, pt, oracle, error_range, hamming_weight),
            move |_tid,
                  abort: Arc<AtomicBool>,
                  (mut pk, mut sk, mut pt, mut oracle, error_range, hamming_weight)| {
                let result = search_genesis_pattern(
                    &mut pk,
                    &mut sk,
                    &mut pt,
                    &mut oracle,
                    hamming_weight,
                    error_range,
                    abort.clone(),
                );
                debug!("Stopped search: {:?}", result);
                abort.store(true, Ordering::Relaxed);
                result
            },
            |sync| sync.load(Ordering::Relaxed),
        )?;
        let attempts: u32 = search_results
            .iter()
            .map(|gsr| match gsr {
                GenesisSearchResults::Success((_, attempts)) => *attempts,
                GenesisSearchResults::Interrupted(attempts) => *attempts,
            })
            .sum();
        info!("Genesis pattern search ended after {} attempts", attempts);
        search_results.into_iter().filter_map(|gsr| match gsr {
            GenesisSearchResults::Success((pattern, _)) => Some(pattern),
            _ => None,
        })
    };

    let chain_length = opt.chain_length;
    if let Some(error_pattern) = patterns.next() {
        oracle.epsilon = opt.epsilon;
        let gcpm = ClonableProgressManager::create();
        gcpm.add(
            0u8,
            chain_length as u64,
            "Generating distance spectrum",
            " [{elapsed_precise}] {bar:40} {pos:>7}/{len:7} [{eta_precise}] {wide_msg} ",
        );
        gcpm.start(None);

        // Main body
        info!("Starting generation of distance spectrum...");
        let mut list_of_lists_of_ds = thread_work(
            opt.threads,
            (pk, sk, pt, oracle, error_pattern, error_range),
            move |_tid,
                  sync: Arc<AtomicU32>,
                  (mut pk, mut sk, mut pt, mut oracle, error_pattern, error_range)| {
                Ok(Some(generate_lists_fgab(
                    &mut pk,
                    &mut sk,
                    &mut pt,
                    &mut oracle,
                    error_pattern,
                    chain_length,
                    error_range,
                    sync,
                )?))
            },
            |sync| {
                let value = sync.load(Ordering::Relaxed);
                gcpm.set_position(0, value as u64);
                gcpm.tick();
                value >= chain_length
            },
        )?;
        info!("Finished generating the distance spectrum...");

        gcpm.set_position(0, chain_length as u64);
        gcpm.tick();
        gcpm.stop();

        // Postamble
        // A' ← (max)(A) −A + min(A)
        // D ←F + G + A′ + B

        info!("Opending target file: {:?}", opt.destination);
        let mut writer = csv::Writer::from_writer(AutoFinishUnchecked::new(
            libflate::gzip::Encoder::new(BufWriter::new(File::create(&opt.destination).strerr()?))
                .strerr()?,
        ));
        writer
            .write_record(&["list", "distance", "count"])
            .strerr()?;

        let decoding_successes: f64 = list_of_lists_of_ds
            .iter()
            .map(|l| l.num_successes as f64)
            .sum();
        let decoding_failure: f64 = list_of_lists_of_ds
            .iter()
            .map(|l| l.num_failures as f64)
            .sum();
        info!(
            "Number of: decoding failures: {}, decoding successes: {}, decoding failure rate: {}",
            decoding_failure,
            decoding_successes,
            decoding_successes / decoding_failure
        );

        if let Some(mut l1) = list_of_lists_of_ds.pop() {
            for l2 in list_of_lists_of_ds {
                l1.f.iter_mut()
                    .zip(l2.f)
                    .for_each(|(dest, src)| *dest += src);
                l1.g.iter_mut()
                    .zip(l2.g)
                    .for_each(|(dest, src)| *dest += src);
                l1.a.iter_mut()
                    .zip(l2.a)
                    .for_each(|(dest, src)| *dest += src);
                l1.b.iter_mut()
                    .zip(l2.b)
                    .for_each(|(dest, src)| *dest += src);
            }
            write_ds(l1.f, "f", &mut writer);
            write_ds(l1.g, "g", &mut writer);
            write_ds(l1.a, "a", &mut writer);
            write_ds(l1.b, "b", &mut writer);
        }
    }

    Ok(())
}

pub fn write_ds<W: Write, I: IntoIterator<Item = u32>>(
    values: I,
    name: &str,
    writer: &mut Writer<W>,
) {
    info!("Writing list {} to target file", name);
    values
        .into_iter()
        .enumerate()
        .for_each(|(distance, count): (usize, u32)| {
            writer
                .write_record(&[name, &distance.to_string(), &count.to_string()])
                .expect("Failed to write to output file");
        });
}

pub fn read_keypair<KEM: Kem>(
    key_file: &Path,
    create_if_missing: bool,
) -> Result<(KEM::PublicKey, KEM::SecretKey), String> {
    match File::open(key_file) {
        Ok(reader) => {
            info!("Reading key-pair from {:?}", key_file);
            Ok(bincode::deserialize_from(reader).strerr()?)
        }
        Err(err) => match err.kind() {
            std::io::ErrorKind::NotFound if create_if_missing => {
                let (pk, sk) = get_keypair::<KEM>()?;

                info!("Writing random key-pair to {:?}", key_file);
                let writer = File::create(key_file).strerr()?;

                // Serialize to file
                bincode::serialize_into(writer, &(&pk, &sk)).strerr()?;

                Ok((pk, sk))
            }
            _ => Err(err.to_string()),
        },
    }
}

#[logfn_inputs(Trace)]
pub fn run<BIKE: 'static + Bike + std::marker::Send>(opt: BikeAttackOptions) -> Result<(), String> {
    info!("Launching rejection sampling attack on BIKE secret key.");

    let (mut pk, mut sk) = if let Some(key_file) = &opt.reuse_key_pair {
        read_keypair::<BIKE>(key_file, true)?
    } else {
        get_keypair::<BIKE>()?
    };

    // pt ← Plaintext such that H(pt) is easily distinguishable by timing attack
    let (inner, pt) = construct_decoding_failure_oracle::<BIKE, BikeIdealizedOracle<BIKE>>(
        &opt.plaintext_db,
        1,
        1,
        1,
        &mut pk,
        &mut sk,
    )?;

    // generate oracle
    let oracle = EpsilonWrappedOracle::wrap(inner, 0.0);

    attack::<BIKE, _>(opt, pk, sk, pt, oracle)?;

    Ok(())
}
