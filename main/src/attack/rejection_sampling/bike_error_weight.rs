use std::{
    marker::PhantomData,
    ops::Range,
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
};

use liboqs_rs_bindings as oqs;
use log::info;
use log_derive::{logfn, logfn_inputs};
use oqs::{bike::Bike, KemBuf};
use rand::thread_rng;
use structopt::StructOpt;

use crate::{
    attack::rejection_sampling::{attack::get_keypair, plaintexts::PlaintextDb},
    utils::{thread_work, ClonableProgressManager, ProgressBars},
};

#[derive(Debug, StructOpt)]
pub struct BikeErrorWeightSearchOptions {
    /// The resulting weight should result in at least this amount of
    /// decoding failures, per '--for-every' amount of attempts
    #[structopt(short, long)]
    above: u32,
    /// The resulting weight should result in at most this amount of
    /// decoding failures, per '--for-every' amount of attempts
    #[structopt(short, long)]
    below: u32,
    /// The number of decoding attempts, per search step.
    #[structopt(short, long)]
    for_every: u32,
    /// Location of plaintext database generated by the "attack rejection-sampling collect-plaintexts" command
    #[structopt(short("d"), long("db"))]
    pub plaintext_db: PathBuf,
}

#[derive(Debug, StructOpt)]
pub struct BikeErrorWeightTestOptions {
    ///
    #[structopt(short, long)]
    weight: usize,
    ///
    #[structopt(short("n"), long)]
    tests: u64,
    ///
    #[structopt(short, long, default_value("1"))]
    threads: usize,
    /// Location of plaintext database generated by the "attack rejection-sampling collect-plaintexts" command
    #[structopt(short("d"), long("db"))]
    pub plaintext_db: PathBuf,
}

pub type SparseErrorPattern = Vec<u32>;

pub trait DecodingFailureOracle<BIKE: Bike>: std::fmt::Debug + Clone + Send {
    const NAME: &'static str;
    fn generate(
        num_profiling: i32,
        num_decaps: i32,
        delta_iter: u32,
        pt: &mut BIKE::Plaintext,
        pt_delta: &mut BIKE::Plaintext,
        pk: &mut BIKE::PublicKey,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<Self>, String>
    where
        Self: Sized;

    fn decoding_failure(
        &mut self,
        ct: &mut BIKE::Ciphertext,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<bool>, String>;
}

#[derive(Debug, Clone)]
pub struct BikeIdealizedOracle<BIKE: Bike> {
    success_iterations: u32,
    _pd: PhantomData<BIKE>,
}

impl<BIKE: Bike + std::marker::Send> DecodingFailureOracle<BIKE> for BikeIdealizedOracle<BIKE> {
    const NAME: &'static str = "IDEAL";

    fn generate(
        _num_profiling: i32,
        _num_decaps: i32,
        _num_validate: u32,
        pt: &mut BIKE::Plaintext,
        _pt2: &mut BIKE::Plaintext,
        pk: &mut BIKE::PublicKey,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<Self>, String>
    where
        Self: Sized,
    {
        let mut ss = BIKE::SharedSecret::new();
        let mut ct = BIKE::Ciphertext::new();

        BIKE::encaps_with_plaintext(&mut ct, &mut ss, pk, pt)?;

        let (success_iterations, _success) = BIKE::decaps_intermediaries(&mut ct, &mut ss, sk)?;

        Ok(Some(Self {
            success_iterations,
            _pd: PhantomData,
        }))
    }

    fn decoding_failure(
        &mut self,
        ct: &mut BIKE::Ciphertext,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<bool>, String> {
        let mut ss = BIKE::SharedSecret::new();

        let (iterations, _success) = BIKE::decaps_intermediaries(ct, &mut ss, sk)?;

        Ok(Some(self.success_iterations != iterations))
    }
}

pub fn random_sparse_error_pattern(
    range: Range<usize>,
    amount: usize,
) -> Result<SparseErrorPattern, String> {
    let mut rng = thread_rng();

    let length = range.end - range.start;
    let shift = range.start;

    // e_0
    let indexes = rand::seq::index::sample(&mut rng, length, amount);

    // Shift indices to range
    Ok(indexes
        .into_vec()
        .into_iter()
        .map(|i| (i + shift) as u32)
        .collect())
}

fn bin_search_approprate_error_weight<BIKE: Bike, ORACLE: DecodingFailureOracle<BIKE>>(
    opt: BikeErrorWeightSearchOptions,
    mut oracle: ORACLE,
    pt: BIKE::Plaintext,
    mut pk: BIKE::PublicKey,
    mut sk: BIKE::SecretKey,
) -> Result<u32, String> {
    let maximum_weight = BIKE::params::<u32>().PARAM_T * 10; //Arbitrarily selected
    let minimum_weight: u32 = BIKE::params().PARAM_T;

    let params = BIKE::params();
    let error_range = params.PARAM_R..params.PARAM_N;
    info!("Found a decoding_Failure oracle!");

    info!("Starting binary search to find the appropriate error weight");
    let mut ct = BIKE::Ciphertext::new();
    let mut ss = BIKE::SharedSecret::new();

    let mut high = maximum_weight;
    let mut low = minimum_weight;
    let weight = 'result: loop {
        if high <= low {
            return Err(format!(
                "Failed binary search due to high({}) <= low({})",
                high, low
            ));
        }
        let middle = (high + low) / 2;
        info!("Testing errors with hamming weight {}", middle);
        let mut decoding_failures = 0;
        let mut attempts = 0;
        'inner: for i in 1..=opt.for_every {
            attempts = i;
            let rsep = random_sparse_error_pattern(error_range.clone(), middle as usize)?;
            BIKE::encaps_with_plaintext_and_error_pattern(&mut ct, &mut ss, &mut pk, &pt, &rsep)?;
            if let Some(measurment) = oracle.decoding_failure(&mut ct, &mut sk)? {
                decoding_failures += measurment as u32
            }
            if decoding_failures > opt.below {
                break 'inner;
            }
        }
        if decoding_failures <= opt.above {
            info!(
                "{} decoding failures (out of {}) are too few, increasing error weight",
                decoding_failures, attempts
            );
            low = middle;
        } else if decoding_failures >= opt.below {
            info!(
                "{} decoding failures (out of {}) are too many, decreasing error weight",
                decoding_failures, attempts
            );
            high = middle;
        } else {
            info!(
                "{} decooding failures (out of {}) is within the specified interval",
                decoding_failures, attempts
            );
            break 'result middle;
        }
    };

    Ok(weight)
}

#[logfn(Trace)]
fn add_se(iter: u32) -> u32 {
    iter + (((iter + 3) / 4) * 1000)
}

#[logfn(Trace)]
fn remove_se(iter: u32) -> u32 {
    iter % 1000
}

#[cfg(test)]
mod tests {

    use super::{add_se, remove_se};

    #[test]
    fn test_add_se() {
        assert_eq!(add_se(172), 43172);
        assert_eq!(add_se(173), 44173);
        assert_eq!(add_se(174), 44174);
        assert_eq!(add_se(175), 44175);
        assert_eq!(add_se(176), 44176);
        assert_eq!(add_se(177), 45177);
    }

    #[test]
    fn test_remove_se() {
        assert_eq!(remove_se(43172), 172);
        assert_eq!(remove_se(44173), 173);
        assert_eq!(remove_se(44174), 174);
        assert_eq!(remove_se(44175), 175);
        assert_eq!(remove_se(44176), 176);
        assert_eq!(remove_se(45177), 177);
    }
}

pub fn construct_decoding_failure_oracle<BIKE: Bike, ORACLE: DecodingFailureOracle<BIKE>>(
    db_location: &Path,
    num_profiling: i32,
    num_decaps: i32,
    delta_iter: u32,
    pk: &mut BIKE::PublicKey,
    sk: &mut BIKE::SecretKey,
) -> Result<(ORACLE, BIKE::Plaintext), String> {
    if delta_iter == 0 {
        return Err(format!("Delta iter ({}) must be grater than 0", delta_iter));
    }
    info!(
        "Constructing a decoding failure oracle of type: {}",
        ORACLE::NAME
    );
    info!("Searching for best candidate plaintext in database...");
    let mut ptdb = PlaintextDb::<BIKE>::new(db_location, 0)?;
    let (min, mut min_pt) = ptdb
        .get_min_max(false)?
        .ok_or_else(|| "No more plaintexts in db!".to_string())?;
    let min = remove_se(min);
    info!(
        "Found candidate with {} iterations in the rejection sampling!",
        min
    );

    let mut selected_iter = min + delta_iter;
    let oracle = loop {
        let mut higher = 0;
        let mut pt_delta = loop {
            if let Some((iter, pt_delta)) =
                ptdb.get_next_iter(add_se(selected_iter + higher), false)?
            {
                let iter = remove_se(iter);
                info!(
                    "Attempting to construct a oracle with granularity of {} PRNG samplings (using a delta plaintext with {} PRNG samplings)!",
                    iter - min,
                    iter
                );
                selected_iter = iter;
                break pt_delta;
            }
            higher += 1;
        };

        if let Some(oracle) = ORACLE::generate(
            num_profiling,
            num_decaps,
            delta_iter,
            &mut min_pt,
            &mut pt_delta,
            pk,
            sk,
        )? {
            break oracle;
        }
    };
    info!("decoding failure oracle constructed!");
    Ok((oracle, min_pt))
}

#[logfn_inputs(Trace)]
pub fn run_search<BIKE: Bike + std::marker::Send>(
    opt: BikeErrorWeightSearchOptions,
) -> Result<(), String> {
    if opt.below <= opt.above {
        return Err(format!("Command line option --below (now: {}) must have a value lower than option --above (now: {})", opt.below, opt.above));
    }

    info!("Launching procedure to find a error weight suitable to launch a rejection sampling attack on BIKE secret key.");

    let (mut pk, mut sk) = get_keypair::<BIKE>()?;
    let (oracle, pt) = construct_decoding_failure_oracle::<BIKE, BikeIdealizedOracle<BIKE>>(
        &opt.plaintext_db,
        1,
        1,
        1,
        &mut pk,
        &mut sk,
    )?;

    let weight = bin_search_approprate_error_weight::<BIKE, _>(opt, oracle, pt, pk, sk)?;

    info!("Selected {} as the most appropriate error weight to use in the rejection sampling attack on BIKE", weight);

    Ok(())
}

#[logfn_inputs(Trace)]
pub fn run_test<BIKE: 'static + Bike + std::marker::Send>(
    opt: BikeErrorWeightTestOptions,
) -> Result<(), String> {
    let (mut pk, mut sk) = get_keypair::<BIKE>()?;

    info!("Launching procedure to test decoding failure rate of {} with weight {} by using {} decapsulation calls", BIKE::NAME, opt.weight, opt.tests);

    let (oracle, pt) = construct_decoding_failure_oracle::<BIKE, BikeIdealizedOracle<BIKE>>(
        &opt.plaintext_db,
        1,
        1,
        1,
        &mut pk,
        &mut sk,
    )?;
    info!("Constructed a decoding_Failure oracle successfully!");

    let cpm = ClonableProgressManager::create();
    cpm.add(
        0,
        opt.tests,
        "0",
        "[{elapsed_precise}] Decoding failures: {msg} {wide_bar} {pos}/{len} ({per_sec}) [{eta_precise}]",
    );

    cpm.start([]);

    let sk = sk.clone();
    let target_weight = opt.weight;
    let target_tests = opt.tests;
    let (decoding_failures, total_tests) = thread_work(
        opt.threads,
        (oracle, pt, pk, sk),
        move |_tid, sync: Arc<(AtomicU64, AtomicU64)>, (mut oracle, pt, mut pk, mut sk)| {
            let mut decoding_failures = 0;
            let mut tests = 0;
            let mut ct = BIKE::Ciphertext::new();
            let mut ss = BIKE::SharedSecret::new();
            let params = BIKE::params();
            let error_range = params.PARAM_R..params.PARAM_N;
            while sync.1.load(Ordering::Relaxed) < target_tests {
                let rsep = random_sparse_error_pattern(error_range.clone(), target_weight)?;
                BIKE::encaps_with_plaintext_and_error_pattern(
                    &mut ct, &mut ss, &mut pk, &pt, &rsep,
                )?;
                if let Some(measurment) = oracle.decoding_failure(&mut ct, &mut sk)? {
                    if measurment {
                        sync.0.fetch_add(1, Ordering::Relaxed);
                        decoding_failures += 1;
                    }
                    tests += 1;
                    sync.1.fetch_add(1, Ordering::Relaxed);
                }
            }
            Ok(Some((decoding_failures, tests)))
        },
        |sync: &Arc<(AtomicU64, AtomicU64)>| {
            let pos = sync.1.load(Ordering::Relaxed);
            let fails = sync.0.load(Ordering::Relaxed);
            cpm.set_position(0, pos);
            cpm.set_message(0, fails.to_string());
            cpm.tick();
            pos >= opt.tests
        },
    )?
    .into_iter()
    .fold((0, 0), |(sum_fails, sum_tests), (fails, tests)| {
        (sum_fails + fails, sum_tests + tests)
    });

    cpm.stop();

    info!(
        "Finished successfully with decoding failure rate: {}/{}={}!",
        decoding_failures,
        opt.tests,
        (decoding_failures as f64 / total_tests as f64).to_string()
    );

    Ok(())
}
