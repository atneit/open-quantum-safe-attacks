use liboqs_rs_bindings as oqs;

use log::{info, warn};
use log_derive::logfn_inputs;
use oqs::{bike::Bike, KemBuf};
use std::{marker::PhantomData, path::PathBuf};
use structopt::StructOpt;

use crate::{
    attack::rejection_sampling::{
        attack::get_keypair,
        attack::record_decaps_to,
        bike_error_weight::{
            construct_decoding_failure_oracle, random_sparse_error_pattern, BikeIdealizedOracle,
        },
    },
    utils::{pb_add, ClonableProgressManager, ProgressBars, Rec, Recorder},
};

use super::bike_error_weight::DecodingFailureOracle;

#[derive(Debug, StructOpt)]
pub struct BikeEvalDistinguisherOptions {
    /// The hamming weight of the error patterns to use.
    #[structopt(short("w"), long)]
    hamming_weight: usize,
    /// The number of decapsulations to measure, in the profiling phase.
    #[structopt(short("p"), long, default_value("1000"))]
    pub num_profiling: i32,
    /// The number of decapsulations to measure, in the profiling phase.
    #[structopt(short("s"), long, default_value("100"))]
    pub num_decaps: i32,
    /// The minimum granularity of the constructed decoder
    #[structopt(short("i"), long, default_value("10"))]
    pub delta_iter: u32,
    /// The number of distinguisher decisions to attempt when evauluating the distinguisher.
    #[structopt(short, long)]
    trials: u64,
    /// Location of plaintext database generated by the "attack rejection-sampling collect-plaintexts" command
    #[structopt(short("d"), long("db"))]
    pub plaintext_db: PathBuf,
}

#[derive(Debug, Clone)]
struct BikeTimingOracle<BIKE>
where
    BIKE: Bike + Send,
{
    _bike: PhantomData<BIKE>,
    num_decaps: i32,
    threshold: u64,
}

impl<BIKE> DecodingFailureOracle<BIKE> for BikeTimingOracle<BIKE>
where
    BIKE: Bike + Send,
{
    const NAME: &'static str = "TIMING";

    fn generate(
        num_profiling: i32,
        num_decaps: i32,
        _num_validate: u32,
        pt: &mut BIKE::Plaintext,
        pt_delta: &mut BIKE::Plaintext,
        pk: &mut BIKE::PublicKey,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<Self>, String>
    where
        Self: Sized,
    {
        let pm = ClonableProgressManager::<u8>::create();
        let total_length = num_profiling * 2; //TODO calculate this value
        let mut total_pos: u64 = 0;

        pm.add(
            0,
            total_length as u64,
            "Gen. timing profile".to_string(),
            " {msg:30} {wide_bar} ETA [{eta_precise}]",
        );
        pm.start([]);

        info!(
            "Starting {} decapsulations of primary plaintext to detect upper timing bound",
            num_profiling
        );

        let mut ct = BIKE::Ciphertext::new();
        let mut ss = BIKE::SharedSecret::new();

        BIKE::encaps_with_plaintext(&mut ct, &mut ss, pk, pt)?;
        let mut rec_first_bound = Recorder::saveall("First bound", None);
        let prof_steps = num_profiling / 10;
        for _ in 0..10 {
            rec_first_bound =
                record_decaps_to::<BIKE, _>(rec_first_bound, &mut ct, sk, prof_steps)?;
            pb_add!(total_pos = pm[0].add(prof_steps as u64));
        }

        let first_bound =
            if let Some(val) = rec_first_bound.nth_lowest_value((num_profiling / 100) as u64) {
                val
            } else {
                warn!("No recordings!");
                return Ok(None);
            };

        info!(
            "1% lowest measurment of selected plaintext: {}",
            first_bound
        );

        BIKE::encaps_with_plaintext(&mut ct, &mut ss, pk, pt_delta)?;
        let mut rec_delta_bound = Recorder::saveall("Second bound", None);
        for _ in 0..10 {
            rec_delta_bound =
                record_decaps_to::<BIKE, _>(rec_delta_bound, &mut ct, sk, prof_steps)?;
            pb_add!(total_pos = pm[0].add(prof_steps as u64));
        }

        let delta_bound =
            if let Some(val) = rec_delta_bound.nth_lowest_value((num_profiling / 100) as u64) {
                val
            } else {
                warn!("No recordings!");
                return Ok(None);
            };

        info!("1% lowest mesurment of delta plaintext: {}", delta_bound);

        if delta_bound <= first_bound {
            warn!("lower bound is higher than the upper bound!");
            return Ok(None);
        }

        Ok(Some(Self {
            _bike: PhantomData,
            num_decaps,
            threshold: delta_bound,
        }))
    }

    fn decoding_failure(
        &mut self,
        ct: &mut BIKE::Ciphertext,
        sk: &mut BIKE::SecretKey,
    ) -> Result<Option<bool>, String> {
        let recorder =
            record_decaps_to::<BIKE, _>(Recorder::saveall("_", None), ct, sk, self.num_decaps)?;
        if let Some(val) = recorder.nth_lowest_value((self.num_decaps / 100) as u64) {
            Ok(Some(val >= self.threshold))
        } else {
            Ok(None)
        }
    }
}

#[logfn_inputs(Trace)]
pub fn run<BIKE: 'static + Bike + std::marker::Send>(
    opt: BikeEvalDistinguisherOptions,
) -> Result<(), String> {
    let params = BIKE::params();
    let error_range = params.PARAM_R..params.PARAM_N;

    let (mut pk, mut sk) = get_keypair::<BIKE>()?;

    let (mut ideal_oracle, pt_ideal) = construct_decoding_failure_oracle::<
        BIKE,
        BikeIdealizedOracle<BIKE>,
    >(&opt.plaintext_db, 1, 1, 1, &mut pk, &mut sk)?;
    let (mut oracle, pt) = construct_decoding_failure_oracle::<BIKE, BikeTimingOracle<BIKE>>(
        &opt.plaintext_db,
        opt.num_profiling,
        opt.num_decaps,
        opt.delta_iter,
        &mut pk,
        &mut sk,
    )?;

    // Should be taken from the same db and thus be the same
    assert_eq!(pt.as_slice(), pt_ideal.as_slice());

    let pm = ClonableProgressManager::<u8>::create();

    pm.add(
        0,
        opt.trials * opt.num_decaps as u64,
        "Testing oracle".to_string(),
        " [{elapsed_precise}] {msg} {wide_bar} {pos}/{len} ({per_sec}) ETA [{eta_precise}]",
    );
    pm.start([]);

    let mut ct = BIKE::Ciphertext::new();
    let mut ss = BIKE::SharedSecret::new();
    let mut num_false_positives = 0;
    let mut num_false_negatives = 0;
    let mut num_undecided = 0;
    let mut num_decoding_failures = 0;
    for i in 0..opt.trials {
        // Create a new ciphertext
        let rsep = random_sparse_error_pattern(error_range.clone(), opt.hamming_weight)?;
        BIKE::encaps_with_plaintext_and_error_pattern(&mut ct, &mut ss, &mut pk, &pt, &rsep)?;
        let truth = ideal_oracle
            .decoding_failure(&mut ct, &mut sk)?
            .expect("Idealized oracle should never fail to give a result!")
            as u64;
        num_decoding_failures += truth;
        if let Some(detected) = oracle.decoding_failure(&mut ct, &mut sk)? {
            let positive = detected as u64;
            num_false_positives += positive & (truth ^ 1); // 1 & (0 ^ 1)
            num_false_negatives += (positive ^ 1) & truth; // (0 ^ 1) & 1
        } else {
            num_undecided += 1;
        }

        let trial_num = i + 1;
        let fp_rate = num_false_positives as f64 / trial_num as f64;
        let fn_rate = num_false_negatives as f64 / trial_num as f64;
        pm.set_message(
            0,
            format!(
                "{} trials, {} false pos. (=>{:.4}), {} false neg. (=>{:.4})",
                trial_num, num_false_positives, fp_rate, num_false_negatives, fn_rate
            ),
        );
        pm.set_position(0, i * opt.num_decaps as u64);
        pm.tick();
    }

    pm.stop();

    let failures = (num_false_positives + num_false_negatives) as f64;
    let fp_rate = (num_false_positives as f64 / opt.trials as f64).to_string();
    let fn_rate = (num_false_negatives as f64 / opt.trials as f64).to_string();
    let epsilon = (failures / (opt.trials as f64)).to_string();
    let dfr = (num_decoding_failures as f64 / opt.trials as f64).to_string();

    info!("Number of trials without decisions: {}", num_undecided);
    info!(
        "Number of false positives: {} (fp rate: {})",
        num_false_positives, fp_rate
    );
    info!(
        "Number of false positives: {} (fp rate: {})",
        num_false_negatives, fn_rate
    );
    info!("Final verdict: BIKE decoding failure distinguisher with {} decapsulations per decision results in a epsilon value of {}, with a DFR of {}", opt.num_decaps, epsilon, dfr);

    Ok(())
}
