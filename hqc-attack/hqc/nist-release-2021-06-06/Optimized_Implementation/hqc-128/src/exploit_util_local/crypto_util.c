
struct timing_info message_timing(uint64_t *m) {
  uint8_t theta[SHAKE256_512_BYTES] = {0};
  static __m256i r2_256[VEC_N_256_SIZE_64 >> 2];
  static __m256i r1_256[VEC_N_256_SIZE_64 >> 2];
  static __m256i e_256[VEC_N_256_SIZE_64 >> 2];
  memset(r2_256, 0, sizeof r2_256);
  memset(r1_256, 0, sizeof r1_256);
  memset(e_256, 0, sizeof e_256);
  // Computing theta
  shake256incctx shake256state;
  shake256_512_ds(&shake256state, theta, (uint8_t*) m, VEC_K_SIZE_BYTES, G_FCT_DOMAIN);

  seedexpander_state seedexpander;
  // Create seed_expander from theta
  seedexpander_init(&seedexpander, theta, SEED_BYTES);
  struct timing_info ti1 = vect_set_random_fixed_weight(&seedexpander, r1_256, PARAM_OMEGA_R);
  struct timing_info ti2 = vect_set_random_fixed_weight(&seedexpander, r2_256, PARAM_OMEGA_R);
  struct timing_info ti3 = vect_set_random_fixed_weight(&seedexpander, e_256, PARAM_OMEGA_E);

  struct timing_info ti = (struct timing_info) {
    .inner_iters = ti1.inner_iters + ti2.inner_iters + ti3.inner_iters,
    .outer_iters = ti1.outer_iters + ti2.outer_iters + ti3.outer_iters,
    .seed_expander_iters = ti1.seed_expander_iters + ti2.seed_expander_iters + ti3.seed_expander_iters,
  };
  return ti;
}

void find_message(uint64_t *dest_m, uint64_t desired_calls, uint64_t iters) {
  uint64_t *counters = calloc(desired_calls, sizeof *counters);
  for (uint64_t i = 0; i < iters; ++i) {
    uint64_t m[VEC_K_SIZE_64] = {0};

    // Computing m
    vect_set_random_from_prng(m);

    struct timing_info ti = message_timing(m);
    if (ti.seed_expander_iters >= desired_calls) {
      memcpy(dest_m, (uint8_t*)m, sizeof m);
      free(counters);
      return;
    }

    counters[ti.seed_expander_iters]++;
  }
  uint64_t sum = 0;
  for (size_t i = 0; i < desired_calls; ++i) {
    sum += counters[i];
    printf("Sexpn %zu: %lu\n", i, counters[i]);
  }
  printf("Total: %lu\n", sum);
  free(counters);
  exit(1);
}


/**
 * Same as hqc_pke_encrypt but only computes mG
 */
void hqc_pke_encrypt_m(int valid, uint64_t *u, uint64_t *v, const uint64_t *m, unsigned char *theta, const unsigned char *pk) {
    seedexpander_state seedexpander;
    static __m256i h_256[VEC_N_256_SIZE_64 >> 2];
    static __m256i s_256[VEC_N_256_SIZE_64 >> 2];
    static __m256i r2_256[VEC_N_256_SIZE_64 >> 2];

    static __m256i r1_256[VEC_N_256_SIZE_64 >> 2];
    static __m256i e_256[VEC_N_256_SIZE_64 >> 2];

    static __m256i tmp1_256[VEC_N_256_SIZE_64 >> 2];
    static __m256i tmp2_256[VEC_N_256_SIZE_64 >> 2];
    static __m256i tmp3_256[VEC_N_256_SIZE_64 >> 2];
    static uint64_t tmp4[VEC_N_256_SIZE_64];

    #ifdef __STDC_LIB_EXT1__
        memset_s(r2_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset_s(h_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset_s(s_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset_s(r1_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset_s(e_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
    #else
        memset(r2_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset(h_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset(s_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset(r1_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
        memset(e_256, 0, (VEC_N_256_SIZE_64 >> 2) * sizeof(__m256i));
    #endif

    // Create seed_expander from theta
    seedexpander_init(&seedexpander, theta, SEED_BYTES);

    // Retrieve h and s from public key
    hqc_public_key_from_string((uint64_t *) h_256, (uint64_t *) s_256, pk);

    // Generate r1, r2 and e
    if (valid) {
      vect_set_random_fixed_weight(&seedexpander, r1_256, PARAM_OMEGA_R);
      vect_set_random_fixed_weight(&seedexpander, r2_256, PARAM_OMEGA_R);
      vect_set_random_fixed_weight(&seedexpander, e_256, PARAM_OMEGA_E);
    } else {
      ((uint8_t*)r1_256)[0] = 1; // TODO
    }

    // Compute u = r1 + r2.h
    vect_mul(tmp1_256, r2_256, h_256);
    vect_add(u, (uint64_t *) r1_256, (uint64_t *) tmp1_256, VEC_N_256_SIZE_64);

    // Compute v = m.G by encoding the message
    code_encode(v, m);
    vect_resize((uint64_t *) tmp2_256, PARAM_N, v, PARAM_N1N2);

    // Compute v = m.G + s.r2 + e
    vect_mul(tmp3_256, r2_256, s_256);
    vect_add(tmp4, (uint64_t *) e_256, (uint64_t *) tmp3_256, VEC_N_256_SIZE_64);
    vect_add((uint64_t *) tmp3_256, (uint64_t *) tmp2_256, tmp4, VEC_N_256_SIZE_64);
    vect_resize(v, PARAM_N1N2, (uint64_t *) tmp3_256, PARAM_N);

    #ifdef VERBOSE
        printf("\n\nh: "); vect_print((uint64_t *) h_256, VEC_N_SIZE_BYTES);
        printf("\n\ns: "); vect_print((uint64_t *) s_256, VEC_N_SIZE_BYTES);
        printf("\n\nr1: "); vect_print((uint64_t *) r1_256, VEC_N_SIZE_BYTES);
        printf("\n\nr2: "); vect_print((uint64_t *) r2_256, VEC_N_SIZE_BYTES);
        printf("\n\ne: "); vect_print((uint64_t *) e_256, VEC_N_SIZE_BYTES);
        printf("\n\ntmp3_256: "); vect_print((uint64_t *) tmp3_256, VEC_N_SIZE_BYTES);

        printf("\n\nu: "); vect_print(u, VEC_N_SIZE_BYTES);
        printf("\n\nv: "); vect_print(v, VEC_N1N2_SIZE_BYTES);
    #endif
}

/**
 * Same as crypto_kem_enc but with a chosen message
 */
int crypto_kem_enc_m(int valid, const uint64_t *m, unsigned char *ct, unsigned char *ss, const unsigned char *pk) {
    #ifdef VERBOSE
        printf("\n\n\n\n### ENCAPS ###");
    #endif

    uint8_t theta[SHAKE256_512_BYTES] = {0};
    // uint64_t m[VEC_K_SIZE_64] = {0};
    static uint64_t u[VEC_N_256_SIZE_64] = {0};
    memset(u, 0, sizeof u);
    uint64_t v[VEC_N1N2_256_SIZE_64] = {0};
    uint8_t d[SHAKE256_512_BYTES] = {0};
    uint8_t mc[VEC_K_SIZE_BYTES + VEC_N_SIZE_BYTES + VEC_N1N2_SIZE_BYTES] = {0};
    shake256incctx shake256state;

    // Computing m
    // vect_set_random_from_prng(m);

    // Computing theta
    shake256_512_ds(&shake256state, theta, (uint8_t*) m, VEC_K_SIZE_BYTES, G_FCT_DOMAIN);

    // Encrypting m
    hqc_pke_encrypt_m(valid, u, v, m, theta, pk);

    // Computing d
    shake256_512_ds(&shake256state, d, (uint8_t *) m, VEC_K_SIZE_BYTES, H_FCT_DOMAIN);

    // Computing shared secret
    memcpy(mc, m, VEC_K_SIZE_BYTES);
    memcpy(mc + VEC_K_SIZE_BYTES, u, VEC_N_SIZE_BYTES);
    memcpy(mc + VEC_K_SIZE_BYTES + VEC_N_SIZE_BYTES, v, VEC_N1N2_SIZE_BYTES);
    shake256_512_ds(&shake256state, ss, mc, VEC_K_SIZE_BYTES + VEC_N_SIZE_BYTES + VEC_N1N2_SIZE_BYTES, K_FCT_DOMAIN);

    // Computing ciphertext
    hqc_ciphertext_to_string(ct, u, v, d);

    #ifdef VERBOSE
        printf("\n\npk: "); for(int i = 0 ; i < PUBLIC_KEY_BYTES ; ++i) printf("%02x", pk[i]);
        printf("\n\nm: "); vect_print(m, VEC_K_SIZE_BYTES);
        printf("\n\ntheta: "); for(int i = 0 ; i < SHAKE256_512_BYTES ; ++i) printf("%02x", theta[i]);
        printf("\n\nd: "); for(int i = 0 ; i < SHAKE256_512_BYTES ; ++i) printf("%02x", d[i]);
        printf("\n\nciphertext: "); for(int i = 0 ; i < CIPHERTEXT_BYTES ; ++i) printf("%02x", ct[i]);
        printf("\n\nsecret 1: "); for(int i = 0 ; i < SHARED_SECRET_BYTES ; ++i) printf("%02x", ss[i]);
    #endif

    return 0;
}