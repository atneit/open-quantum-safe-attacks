/**
 * A dynamically sized vector type
 */

// A Vec<u8>
typedef struct {
  uint8_t *v;
  size_t len;
  size_t capacity;
} Vec;

// A Vec<Vec<u8>>
typedef struct {
  Vec *v;
  size_t len;
  size_t capacity;
} Vecs;

// Create a new Vec
Vec vec_new() {
  return (Vec) {
    .v = NULL,
    .len = 0,
    .capacity = 0,
  };
}

// Append an element
void vec_push(Vec *v, uint8_t elem) {
  if (v->len >= v->capacity) {
    size_t new_size = 2 * v->capacity;
    if (new_size == 0) {
      new_size = 2;
    }
    uint8_t *v_new = realloc(v->v, new_size * sizeof *v->v);
    assert(v_new != NULL);
    v->v = v_new;
    v->capacity = new_size;
  }
  v->v[v->len++] = elem;
}

// Reduce memory footprint to used length
void vec_fit(Vec *v) {
  if (v->capacity > v->len) {
    v->v = realloc(v->v, v->len * sizeof *v->v);
    v->capacity = v->len;
  }
}

// Remove element from the end
void vec_pop(Vec *v) {
  assert(v->len > 0);
  v->len -= 1;
}

// Create a copy of a Vec
Vec vec_copy(Vec *v) {
  size_t cap = v->len;
  size_t size = cap * sizeof *v->v;
  uint8_t *v_copy = malloc(size);
  memcpy(v_copy, v->v, size);
  return (Vec) {
    .v = v_copy,
    .len = v->len,
    .capacity = cap,
  };
}

// Create a new Vecs
Vecs vecs_new() {
  return (Vecs) {
    .v = NULL,
    .len = 0,
    .capacity = 0,
  };
}

// Append a Vec to the Vecs
void vecs_push(Vecs *v, Vec elem) {
  if (v->len >= v->capacity) {
    size_t new_size = 2 * v->capacity;
    if (new_size == 0) {
      new_size = 2;
    }
    Vec *v_new = realloc(v->v, new_size * sizeof *v->v);
    assert(v_new != NULL);
    v->v = v_new;
    v->capacity = new_size;
  }
  v->v[v->len++] = elem;
}

// Reduce memory footprint to used length
void vecs_fit(Vecs *v) {
  if (v->capacity > v->len) {
    v->v = realloc(v->v, v->len * sizeof *v->v);
    v->capacity = v->len;
  }
}

// Free Vec
void vec_free(Vec *v) {
  free(v->v);
  v->v = NULL;
}

// Free Vecs
void vecs_free(Vecs *v) {
  for (size_t i = 0; i < v->len; ++i) {
    vec_free(&(v->v[i]));
  }
  free(v->v);
  v->v = NULL;
}

// Remove element in Vecs
// by placing the element at the end
// at the index to remove.
void vecs_swap_remove(Vecs *v, size_t idx) {
  assert(idx < v->len);
  vec_free(&(v->v[idx]));
  v->v[idx] = v->v[--v->len];
}

// Check if Vec a and Vec b are equal
int vec_eq(const Vec a, const Vec b) {
  if (a.len != b.len) {
    return 0;
  }
  int eq = 1;
  for (size_t i = 0; i < a.len; ++i) {
    eq &= a.v[i] == b.v[i];
  }
  return eq;
}

// Check if a Vec is contained in a Vecs
int vecs_contains(const Vecs v, const Vec e) {
  for (size_t i = 0; i < v.len; ++i) {
    if (vec_eq(v.v[i], e)) {
      return 1;
    }
  }
  return 0;
}

// Print a Vec
void vec_print(Vec v) {
  printf("Length %ld: ", v.len);
  for (size_t j = 0; j < v.len; ++j) {
    printf("%2d", v.v[j]);
    if (j + 1 < v.len) {
      printf(", ");
    }
  }
  printf("\n");
}

// Generate all Vec containing the support (indices where the vector is 1) of binary vectors of length length
// with w_low <= weight of binary vector <= w_high.
// Store these Vec in vecs.
// Vec vec is used as a working variable.
void vecs_of_weight_idx(Vecs *vecs, Vec *vec, int length, int start, int w_low, int w_high) {
  if (w_low <= 0 && 0 <= w_high) {
    vecs_push(vecs, vec_copy(vec));
    if (w_high == 0) {
      return;
    }
  }
  for (int i = start; i < length; ++i) {
    vec_push(vec, i);
    vecs_of_weight_idx(vecs, vec, length, i+1, w_low-1, w_high-1);
    vec_pop(vec);
  }
}

Vecs generate_error_patterns() {
  Vecs vs = vecs_new();
  Vec v = vec_new();
  vecs_of_weight_idx(&vs, &v, PARAM_N2, 0, 0, MAX_E);
  return vs;
}

Vecs generate_inside_patterns() {
  Vecs vs = vecs_new();
  Vec v = vec_new();
  vecs_of_weight_idx(&vs, &v, PARAM_N - PARAM_N1N2, 0, 0, 2);
  return vs;
}

Vec sample_action(size_t weight) {
  Vec v = vec_new();
  while (v.len < weight) {
    uint8_t pos = rand_mod(PARAM_N2);
    int exists = 0;
    for (size_t i = 0; i < v.len; ++i) {
      exists |= v.v[i] == pos;
    }
    if (!exists) {
      vec_push(&v, pos);
    }
  }
  return v;
}

Vecs sample_actions(int n) {
  Vecs vs = vecs_new();
  for (size_t w = H - MAX_E; w <= H + MAX_E; ++w) {
    for (int j = 0; j < n; ++j) {
      vecs_push(&vs, sample_action(w));
    }
  }
  return vs;
}

size_t combined_weight(Vec a, Vec b) {
  // compute the weight if we were to add these two vectors
  size_t weight = a.len + b.len;
  // subtract 2 * intersection, since we counted them twice
  for (size_t i = 0; i < a.len; ++i) {
    for (size_t j = 0; j < b.len; ++j) {
      weight -= 2 * (a.v[i] == b.v[j]);
    }
  }
  return weight;
}
