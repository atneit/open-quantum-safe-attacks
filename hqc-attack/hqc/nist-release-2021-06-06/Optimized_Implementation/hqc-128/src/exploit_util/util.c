/**
 * Utility functions
 */

// Print a buffer of size s in hex
void print_hex(unsigned char *v, size_t s) {
  for (size_t j = 0; j < s; ++j) {
    printf("%02x", v[j]);
  }
  printf("\n");
}

// Print a buffer of size s in hex
// with len bytes per line
// and replacing 0 bytes with "--" for better clarity
void print_hex0(unsigned char *v, size_t s) {
  size_t len = 70;
  for (size_t j = 0; j < s; ++j) {
    if (j % len == 0) {
      printf("\n%02ld: ", j/len);
    }
    if (v[j] == 0) {
      printf("--");
    } else {
      printf("%02x", v[j]);
    }
  }
  printf("\n");
}

// Generate a random number in {0, ..., m-1}
size_t rand_mod(size_t m) {
  assert(m < 1ll<<32);
  uint64_t r;
  _Static_assert(sizeof r == sizeof(size_t), "Need 64bit");
  if (getrandom(&r, sizeof r, 0) != sizeof r) {
    perror("Failed to get random");
    exit(1);
  }
  return (size_t)(r % (uint64_t)m); // Should be safe since r has at least twice as many bits as m
}

// Shuffle the array v of size n
void shuffle(size_t *v, size_t n) {
  for (size_t i = 0; i < n-1; ++i) {
    size_t j = rand_mod(n-i) + i;
    size_t tmp = v[i];
    v[i] = v[j];
    v[j] = tmp;
  }
}

// XOR a and b and place the result in dest
// All arrays must be of length n
void xor_dest(uint8_t *dest, uint8_t *a, uint8_t *b, size_t n) {
  for (size_t i = 0; i < n; ++i) {
    dest[i] = a[i] ^ b[i];
  }
}


// Get a specific bit from an array
int get_bit(const uint8_t *v, size_t bit_pos) {
  size_t byte_to_flip = bit_pos / 8;
  size_t bit_to_flip = (bit_pos % 8);
  return !!(v[byte_to_flip] & (1<<bit_to_flip));
}

// Flip a specific bit in an array
void flip_bit(uint8_t *v, size_t bit_flip_pos) {
  size_t byte_to_flip = bit_flip_pos / 8;
  size_t bit_to_flip = (bit_flip_pos % 8);
  v[byte_to_flip] ^= (1<<bit_to_flip);
}

// Set a specific bit to a specific value in an array v
void set_bit(uint8_t *v, size_t bit_flip_pos, int bit) {
  size_t byte_to_flip = bit_flip_pos / 8;
  size_t bit_to_flip = (bit_flip_pos % 8);
  if (bit) {
    v[byte_to_flip] |= (1<<bit_to_flip);
  } else {
    v[byte_to_flip] &= ~(1<<bit_to_flip);
  }
}

// Determine whether key1 and key2 are equal
// Print an error and exit the program if that's not the case
void check_key(unsigned char* key1, unsigned char* key2, size_t size) {
  if (memcmp(key1, key2, size)) {
    puts("Error checking key. Maybe your openssl is too new?");
    print_hex(key1, size);
    print_hex(key2, size);
    exit(1);
  }
}

// Read a fixed number of bytes.
// Exit the program if the bytes are not available.
void fread_exact(void *ptr, size_t size, size_t nmemb, FILE *stream) {
  if (fread(ptr, size, nmemb, stream) != nmemb) {
    perror("Could not complete read");
    exit(1);
  }
}

// Write a fixed number of bytes.
// Exit the program if the bytes could not be written.
void fwrite_exact(const void *ptr, size_t size, size_t nmemb, FILE *stream) {
  if (fwrite(ptr, size, nmemb, stream) != nmemb) {
    perror("Could not complete write");
    exit(1);
  }
}

void read_exact(int fd, uint8_t *ptr, size_t n) {
  uint8_t *read_ptr = ptr;
  size_t read_so_far = 0;
  while (read_so_far != n) {
    ssize_t valread = read(fd, read_ptr, n - read_so_far);
    if (valread <= 0) {
      perror("Failed to read");
      exit(1);
    }
    read_so_far += valread;
    read_ptr += valread;
  }
}
